import Anthropic from '@anthropic-ai/sdk';
import { AcceptanceCriterion } from '../shared/types';

// Initialize the Claude API with the API key
const apiKey = process.env.ANTHROPIC_API_KEY || '';
const anthropic = new Anthropic({
  apiKey
});

/**
 * Generate requirements using Claude AI
 * @param context Input context for Claude to analyze
 * @param projectName Name of the project for context
 * @param fileName Name of the file being processed
 * @param contentType Type of content in the file
 * @param minRequirements Minimum number of requirements to generate
 * @returns Array of requirements with titles, descriptions, categories, and priorities
 */
export async function generateRequirementsWithClaude(
  context: string,
  projectName: string,
  fileName: string,
  contentType: string = 'general',
  minRequirements: number = 5
): Promise<any[]> {
  try {
    if (!apiKey) {
      console.error('Missing ANTHROPIC_API_KEY environment variable');
      throw new Error('Claude API key is not configured. Please set the ANTHROPIC_API_KEY environment variable.');
    }

    console.log(`Generating requirements with Claude for ${fileName}, content type: ${contentType}`);
    
    // Create a Claude-specific prompt for requirement generation
    const prompt = `
    You are a business analyst with expertise in software migration projects. Analyze the provided content and extract clear, detailed requirements for implementing the described functionality in a target system.

    Project: ${projectName}
    Content Type: ${contentType}
    File: ${fileName}

    Content to analyze:
    ${context}

    Extract at least ${minRequirements} requirements from this content. For each requirement:
    1. Provide a concise title (3-10 words) that summarizes the requirement
    2. Provide a detailed, specific description of at least 150 words that thoroughly explains what needs to be implemented
    3. Classify it into one of these categories: 'functional', 'non-functional', 'security', 'performance'
    4. Assign a priority level: 'high', 'medium', or 'low'

    Format your response as a JSON array of requirements, each with the properties 'title', 'description', 'category', and 'priority'.
    
    Example:
    [
      {
        "title": "Customer Data Migration",
        "description": "The system must implement a comprehensive customer data migration process that preserves all customer information... [detailed 150+ word description]",
        "category": "functional",
        "priority": "high"
      }
    ]
    `;

    // Call Claude API to generate requirements
    const message = await anthropic.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 4000,
      temperature: 0.2,
      system: "You are a business analyst specializing in requirement extraction for software migration projects. Extract detailed, specific requirements from provided content and format them as valid JSON with no additional text.",
      messages: [
        { role: 'user', content: prompt }
      ]
    });

    // Extract the response text
    const responseText = typeof message.content[0] === 'object' && 'text' in message.content[0] 
      ? message.content[0].text as string
      : JSON.stringify(message.content[0]);
    
    // Parse the JSON response
    try {
      // Extract just the JSON part from the response 
      const jsonMatch = responseText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const jsonText = jsonMatch[0];
        const parsedResponse = JSON.parse(jsonText);
        
        console.log(`Claude extracted ${parsedResponse.length} requirements from the content`);
        return parsedResponse;
      } else {
        // If no JSON array was found, try parsing the whole response
        const parsedResponse = JSON.parse(responseText);
        console.log(`Claude extracted ${parsedResponse.length} requirements from the content`);
        return parsedResponse;
      }
    } catch (parseError) {
      console.error('Failed to parse JSON response from Claude:', parseError);
      throw new Error('Invalid response format from Claude API');
    }
  } catch (error) {
    console.error('Error generating requirements with Claude:', error);
    throw error;
  }
}

/**
 * Generate Salesforce-specific implementation tasks for requirements
 * @param projectName Name of the project for context
 * @param sourceSystem Name of the source system
 * @param targetSystem Name of the target system (typically Salesforce)
 * @param projectDescription Description of the project for context
 * @param requirementText The requirement text
 * @param acceptanceCriteria Array of acceptance criteria for this requirement
 * @returns Promise resolving to an array of implementation tasks with Salesforce-specific details
 */
export async function generateImplementationTasks(
  projectName: string,
  sourceSystem: string,
  targetSystem: string,
  projectDescription: string,
  requirementText: string,
  acceptanceCriteria: AcceptanceCriterion[],
  requirementId: number
): Promise<any[]> {
  try {
    if (!apiKey) {
      console.log('ANTHROPIC_API_KEY not found, using mock implementation tasks');
      return getMockImplementationTasks(requirementText, acceptanceCriteria, requirementId, sourceSystem, targetSystem);
    }

    console.log(`Generating implementation tasks for requirement ID ${requirementId}`);
    
    // Format the acceptance criteria for the prompt
    const formattedCriteria = acceptanceCriteria.map(criterion => 
      `- ${criterion.title}:\n  ${criterion.description}`
    ).join('\n\n');

    // Create a prompt for implementation task generation
    const prompt = `
      You are an AI assistant tasked with generating detailed implementation tasks for a software migration project. Your responses should be grounded in the provided documentation of the Target System.

      **Please use the following information to generate implementation tasks:**

      **Project Description:** ${projectDescription}

      **Target System:** ${targetSystem}

      **Requirement Description:** ${requirementText}

      **Acceptance Criteria:**
      ${formattedCriteria}

      **Based on the above information and your understanding of the Target System, generate implementation tasks with the following structure, returned as a structured JSON array:**

      [
        {
          "taskTitle": "[A concise and descriptive title for the task]",
          "highLevelDescription": "[A brief overview of what the task entails]",
          "description": "[A more detailed explanation for backward compatibility]",
          "status": "pending",
          "priority": "medium",
          "system": "target",
          "requirementId": "${requirementId}",
          "estimatedHours": 4,
          "complexity": "medium",
          "taskType": "implementation",
          "detailedImplementationSteps": [
            {
              "stepNumber": 1,
              "stepDescription": "[A specific, actionable step grounded in the Target System's documentation. Include a reference to the relevant documentation if possible.]",
              "relevantDocumentationLinks": ["[Link 1]", "[Link 2]"]
            },
            {
              "stepNumber": 2,
              "stepDescription": "[Another specific, actionable step grounded in the Target System's documentation. Include a reference to the relevant documentation if possible.]",
              "relevantDocumentationLinks": ["[Link 1]", "[Link 2]"]
            }
          ],
          "documentationLinks": ["[Link 1]", "[Link 2]"]
        }
      ]
      
      For each task:
      1. Consider both "${sourceSystem}" system analysis tasks and "${targetSystem}" implementation tasks
      2. Include specific "${targetSystem}" features, objects, and components relevant to the implementation
      3. Reference appropriate "${targetSystem}" documentation URLs wherever possible
      4. Include specific technical details about HOW to implement in "${targetSystem}"
      5. Provide realistic complexity (low, medium, high) and development hours
      6. Include detailed implementation steps with numbered sequences
      7. Ensure documentation links are accurate and relevant

      Only output valid JSON with no additional text or explanations.
    `;

    // Generate content using Claude
    const message = await anthropic.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 3000,
      temperature: 0.7,
      system: 'You are a Salesforce technical architect specialized in implementing complex migration projects and integrations.',
      messages: [
        { role: 'user', content: prompt }
      ]
    });

    // Extract and parse the JSON response
    let responseText = '';
    
    // Handle different types of content from Claude
    if (message.content && message.content.length > 0) {
      const content = message.content[0];
      if (typeof content === 'object') {
        const contentObj = content as any;
        responseText = contentObj.text || JSON.stringify(content);
      } else {
        responseText = String(content);
      }
    }
    
    try {
      // Extract just the JSON part from the response
      const jsonMatch = responseText.match(/\[[\s\S]*\]/);
      let rawTasks: any[] = [];
      
      if (jsonMatch) {
        const jsonText = jsonMatch[0];
        rawTasks = JSON.parse(jsonText);
      } else {
        // If no JSON array was found, try parsing the whole response
        rawTasks = JSON.parse(responseText);
      }
      
      console.log(`Generated ${rawTasks.length} raw implementation tasks`);
      
      // Map the raw tasks from the new structure to our database schema
      const implementationTasks = rawTasks.map((task: any) => {
        // Map detailedImplementationSteps to implementationSteps with our schema
        let implementationSteps: any[] = [];
        if (task.detailedImplementationSteps && Array.isArray(task.detailedImplementationSteps)) {
          implementationSteps = task.detailedImplementationSteps.map((step: any) => ({
            stepNumber: step.stepNumber,
            description: step.stepDescription,
            documentationLinks: step.relevantDocumentationLinks || []
          }));
        }
        
        // Create properly formatted task
        return {
          title: task.taskTitle || task.title,
          description: task.description || "",
          status: task.status || "pending",
          priority: task.priority || "medium",
          system: task.system || "target",
          requirementId: task.requirementId || requirementId,
          estimatedHours: task.estimatedHours || null,
          complexity: task.complexity || "medium",
          assignee: task.assignee || null,
          taskType: task.taskType || "implementation",
          
          // New fields
          highLevelDescription: task.highLevelDescription || null,
          implementationSteps: implementationSteps,
          documentationLinks: task.documentationLinks || [],
          
          // For backward compatibility
          sfDocumentationLinks: task.sfDocumentation || []
        };
      });
      
      console.log(`Mapped ${implementationTasks.length} implementation tasks to schema`);
      return implementationTasks;
    } catch (parseError) {
      console.error('Error parsing Claude response:', parseError);
      console.error('Raw response:', responseText);
      throw new Error('Failed to parse implementation tasks from Claude response');
    }
  } catch (error) {
    console.error('Error generating implementation tasks with Claude:', error);
    throw error;
  }
}

/**
 * Generate mock implementation tasks for demo purposes
 * This function creates realistic-looking Salesforce implementation tasks based on requirement text and acceptance criteria
 * @param requirementText The requirement text
 * @param acceptanceCriteria The acceptance criteria for the requirement
 * @param requirementId The requirement ID
 * @param sourceSystem The source system (e.g., Oracle)
 * @param targetSystem The target system (e.g., Salesforce)
 * @returns An array of mock implementation tasks
 */
function getMockImplementationTasks(
  requirementText: string, 
  acceptanceCriteria: AcceptanceCriterion[], 
  requirementId: number,
  sourceSystem: string,
  targetSystem: string
): any[] {
  // Implementation details for the mock tasks...
  // This would typically generate sample tasks based on the requirement
  
  return [
    {
      title: `Configure ${sourceSystem} to ${targetSystem} Data Migration`,
      description: `Set up a comprehensive data migration process from ${sourceSystem} to ${targetSystem}`,
      status: "pending",
      priority: "medium",
      system: "both",
      requirementId: requirementId,
      estimatedHours: 16,
      complexity: "medium",
      taskType: "implementation",
      highLevelDescription: "Configure the necessary components to enable seamless data transfer between systems",
      implementationSteps: [
        {
          stepNumber: 1,
          description: `Analyze ${sourceSystem} data structure and identify migration targets`,
          documentationLinks: ["https://example.com/docs/migration-planning"]
        },
        {
          stepNumber: 2,
          description: `Set up ${targetSystem} objects and fields to receive data`,
          documentationLinks: ["https://example.com/docs/object-configuration"]
        }
      ],
      documentationLinks: ["https://example.com/docs/migration-guide"],
      sfDocumentationLinks: [
        {
          title: "Data Migration Best Practices",
          url: "https://example.com/docs/migration-best-practices"
        }
      ]
    }
  ];
}

/**
 * Generate acceptance criteria in Gherkin format using Claude
 * @param projectName Name of the project for context
 * @param projectDescription Description of the project for context
 * @param requirementText The requirement text to generate acceptance criteria for
 * @returns Promise resolving to an array of acceptance criteria in Gherkin format
 */
export async function generateAcceptanceCriteria(
  projectName: string,
  projectDescription: string,
  requirementText: string
): Promise<AcceptanceCriterion[]> {
  try {
    if (!apiKey) {
      console.log('ANTHROPIC_API_KEY not found, using mock acceptance criteria');
      return getMockAcceptanceCriteria(requirementText);
    }

    console.log(`Generating acceptance criteria for requirement: ${requirementText.substring(0, 50)}...`);

    // Create a prompt for acceptance criteria generation
    const prompt = `
      You are a business analyst assisting with a software migration project. 
      
      Project Name: ${projectName}
      Project Description: ${projectDescription}
      
      Based on the following requirement, generate 10-20 comprehensive acceptance criteria in Gherkin format.
      
      Requirement: ${requirementText}
      
      For each acceptance criterion:
      1. Create a descriptive title (5-10 words)
      2. Write a proper Gherkin scenario with Given/When/Then format
      3. Ensure criteria are testable, unambiguous, and specific to the requirement
      4. Include edge cases and validation rules where appropriate
      5. Focus on functional behavior rather than implementation details
      
      Return your response as a JSON array where each item has:
      - "title": A concise title for the criterion
      - "gherkin": An object with "scenario", "given", "when", "then" properties
      
      Example response format:
      [
        {
          "title": "Successful customer record creation",
          "gherkin": {
            "scenario": "Customer record is successfully created",
            "given": "The user has valid customer data",
            "when": "The user submits the customer creation form",
            "then": "A new customer record is created in the system"
          }
        }
      ]
      
      Provide only the JSON array without additional text or explanations.
    `;

    // Call Claude API to generate acceptance criteria
    const message = await anthropic.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 4000, // Increased from 2000 to 4000 for more comprehensive criteria
      temperature: 0.3,
      system: "You are a business analyst specializing in writing high-quality acceptance criteria in Gherkin format. Generate comprehensive, testable criteria that cover the full scope of the requirement.",
      messages: [
        { role: 'user', content: prompt }
      ]
    });

    // Extract the response text
    const responseText = typeof message.content[0] === 'object' && 'text' in message.content[0] 
      ? message.content[0].text as string 
      : JSON.stringify(message.content[0]);

    // Parse the JSON response
    try {
      // Extract just the JSON part from the response 
      const jsonMatch = responseText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const jsonText = jsonMatch[0];
        const parsedResponse = JSON.parse(jsonText);
        
        console.log(`Claude generated ${parsedResponse.length} acceptance criteria`);
        return parsedResponse;
      } else {
        // If no JSON array was found, try parsing the whole response
        const parsedResponse = JSON.parse(responseText);
        console.log(`Claude generated ${parsedResponse.length} acceptance criteria`);
        return parsedResponse;
      }
    } catch (parseError) {
      console.error('Failed to parse JSON response from Claude:', parseError);
      console.error('Raw response:', responseText);
      throw new Error('Invalid response format from Claude API');
    }
  } catch (error) {
    console.error('Error generating acceptance criteria with Claude:', error);
    throw error;
  }
}

/**
 * Generate mock acceptance criteria for demo purposes
 * This function creates realistic-looking acceptance criteria based on the requirement text
 * @param requirementText The requirement text to generate criteria for
 * @returns An array of mock acceptance criteria
 */
function getMockAcceptanceCriteria(requirementText: string): AcceptanceCriterion[] {
  // Generate UUIDs for the mock data
  const generateUUID = (): string => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  };

  // Create mock acceptance criteria based on the context of the requirement
  const mockCriteria = [];
  
  // Add generic criteria
  mockCriteria.push({
    id: generateUUID(),
    title: "Successful data migration verification",
    gherkin: {
      scenario: "Successful verification of migrated data",
      given: "The migration process has completed",
      when: "A verification process is run against the data",
      then: "All records should match between source and target systems"
    }
  });
  
  mockCriteria.push({
    id: generateUUID(),
    title: "Error handling during migration",
    gherkin: {
      scenario: "Error handling during data migration",
      given: "The migration process encounters an error",
      when: "A record fails to migrate properly",
      then: "The system should log the error and continue with remaining records"
    }
  });
  
  // Add more criteria based on keywords in the requirement
  if (requirementText.toLowerCase().includes('user interface') || requirementText.toLowerCase().includes('ui')) {
    mockCriteria.push({
      id: generateUUID(),
      title: "UI Responsiveness",
      gherkin: {
        scenario: "Interface response times meet performance criteria",
        given: "A user is interacting with the system",
        when: "Any UI action is performed",
        then: "The interface should respond within 2 seconds"
      }
    });
  }
  
  if (requirementText.toLowerCase().includes('report')) {
    mockCriteria.push({
      id: generateUUID(),
      title: "Report Generation",
      gherkin: {
        scenario: "Generation of reports with migrated data",
        given: "Migrated data is available in the target system",
        when: "A user requests a standard report",
        then: "The report should display accurate data from the migrated dataset"
      }
    });
  }
  
  if (requirementText.toLowerCase().includes('authentication') || requirementText.toLowerCase().includes('security')) {
    mockCriteria.push({
      id: generateUUID(),
      title: "Security Controls Verification",
      gherkin: {
        scenario: "Verification of security controls post-migration",
        given: "User permissions have been migrated",
        when: "A user attempts to access restricted data",
        then: "Access should be granted or denied according to their permission level"
      }
    });
  }
  
  return mockCriteria;
}