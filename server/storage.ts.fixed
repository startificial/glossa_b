import { 
  users, type User, type InsertUser,
  invites, type Invite, type InsertInvite,
  projects, type Project, type InsertProject,
  customers, type Customer, type InsertCustomer,
  inputData, type InputData, type InsertInputData,
  requirements, type Requirement, type InsertRequirement,
  activities, type Activity, type InsertActivity,
  implementationTasks, type ImplementationTask, type InsertImplementationTask
} from "@shared/schema";
import { ExtendedImplementationTask } from './extended-types';
import { and, desc, eq, or, like, sql as drizzleSql, gte, lte } from 'drizzle-orm';
import { db, sql } from './db';
import session from "express-session";
import connectPg from "connect-pg-simple";

// Create PostgreSQL session store
const PostgresSessionStore = connectPg(session);

// Storage interface with session store
export interface IStorage {
  // Session store for Express
  sessionStore: session.Store;
  
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, userData: Partial<InsertUser>): Promise<User | undefined>;
  authenticateUser(usernameOrEmail: string, password: string): Promise<User | undefined>;

  // Invite methods
  getInvite(token: string): Promise<Invite | undefined>;
  getInvitesByCreator(userId: number): Promise<Invite[]>;
  createInvite(invite: InsertInvite): Promise<Invite>;
  markInviteAsUsed(token: string): Promise<Invite | undefined>;

  // Customer methods
  getCustomer(id: number): Promise<Customer | undefined>;
  getAllCustomers(): Promise<Customer[]>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: number, customer: Partial<InsertCustomer>): Promise<Customer | undefined>;
  deleteCustomer(id: number): Promise<boolean>;

  // Project methods
  getProject(id: number): Promise<Project | undefined>;
  getProjects(userId: number): Promise<Project[]>;
  createProject(project: InsertProject): Promise<Project>;
  updateProject(id: number, project: Partial<InsertProject>): Promise<Project | undefined>;
  deleteProject(id: number): Promise<boolean>;

  // Input data methods
  getInputData(id: number): Promise<InputData | undefined>;
  getInputDataByProject(projectId: number): Promise<InputData[]>;
  createInputData(data: InsertInputData): Promise<InputData>;
  updateInputData(id: number, data: Partial<InsertInputData>): Promise<InputData | undefined>;
  deleteInputData(id: number): Promise<boolean>;

  // Requirement methods
  getRequirement(id: number): Promise<Requirement | undefined>;
  getRequirementWithProjectCheck(id: number, projectId: number): Promise<Requirement | undefined>;
  getRequirementsByProject(projectId: number): Promise<Requirement[]>;
  getRequirementsByInputData(inputDataId: number): Promise<Requirement[]>;
  createRequirement(requirement: InsertRequirement): Promise<Requirement>;
  updateRequirement(id: number, requirement: Partial<InsertRequirement>): Promise<Requirement | undefined>;
  deleteRequirement(id: number): Promise<boolean>;
  getHighPriorityRequirements(projectId: number, limit?: number): Promise<Requirement[]>;
  invalidateRequirementCache?(id: number): void; // Optional method to invalidate any cached requirement data

  // Activity methods
  getActivitiesByProject(projectId: number, limit?: number): Promise<Activity[]>;
  getAllActivities(limit?: number): Promise<Activity[]>;
  createActivity(activity: InsertActivity): Promise<Activity>;
  
  // Implementation Task methods
  getImplementationTask(id: number): Promise<ExtendedImplementationTask | undefined>;
  getImplementationTasksByRequirement(requirementId: number): Promise<ExtendedImplementationTask[]>;
  createImplementationTask(task: InsertImplementationTask): Promise<ImplementationTask>;
  updateImplementationTask(id: number, task: Partial<InsertImplementationTask>): Promise<ImplementationTask | undefined>;
  deleteImplementationTask(id: number): Promise<boolean>;
  
  // Search methods
  quickSearch(userId: number, query: string, limit?: number): Promise<{
    projects: Project[];
    requirements: Requirement[];
  }>;
  
  advancedSearch(userId: number, query: string, filters?: {
    entityTypes?: string[];
    projectId?: number;
    category?: string;
    priority?: string;
    dateRange?: { from?: Date; to?: Date };
  }, pagination?: {
    page: number;
    limit: number;
  }): Promise<{
    projects: Project[];
    requirements: Requirement[];
    inputData: InputData[];
    tasks: ExtendedImplementationTask[];
    totalResults: number;
    totalPages: number;
  }>;
}

// PostgreSQL Database Storage Implementation
export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;

  constructor() {
    // Initialize session store with PostgreSQL
    this.sessionStore = new PostgresSessionStore({ 
      conObject: { 
        connectionString: process.env.DATABASE_URL 
      },
      createTableIfMissing: true 
    });
  }

  // User methods
  async getUser(id: number): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.id, id)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching user:', error);
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.username, username)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching user by username:', error);
      return undefined;
    }
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.email, email)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching user by email:', error);
      return undefined;
    }
  }

  async authenticateUser(usernameOrEmail: string, password: string): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(
        and(
          or(
            eq(users.username, usernameOrEmail),
            eq(users.email, usernameOrEmail)
          ),
          eq(users.password, password)
        )
      ).limit(1);
      
      return result[0];
    } catch (error) {
      console.error('Error authenticating user:', error);
      return undefined;
    }
  }

  async createUser(user: InsertUser): Promise<User> {
    try {
      const [newUser] = await db.insert(users).values(user).returning();
      return newUser;
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  }

  async updateUser(id: number, userData: Partial<InsertUser>): Promise<User | undefined> {
    try {
      const [updatedUser] = await db.update(users)
        .set({ ...userData, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      
      return updatedUser;
    } catch (error) {
      console.error('Error updating user:', error);
      return undefined;
    }
  }

  // Invite methods
  async getInvite(token: string): Promise<Invite | undefined> {
    try {
      const result = await db.select().from(invites).where(eq(invites.token, token)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching invite:', error);
      return undefined;
    }
  }

  async getInvitesByCreator(userId: number): Promise<Invite[]> {
    try {
      return await db.select().from(invites).where(eq(invites.createdById, userId));
    } catch (error) {
      console.error('Error fetching invites by creator:', error);
      return [];
    }
  }

  async createInvite(invite: InsertInvite): Promise<Invite> {
    try {
      const [newInvite] = await db.insert(invites).values(invite).returning();
      return newInvite;
    } catch (error) {
      console.error('Error creating invite:', error);
      throw error;
    }
  }

  async markInviteAsUsed(token: string): Promise<Invite | undefined> {
    try {
      const [updatedInvite] = await db.update(invites)
        .set({ used: true })
        .where(eq(invites.token, token))
        .returning();
      
      return updatedInvite;
    } catch (error) {
      console.error('Error marking invite as used:', error);
      return undefined;
    }
  }

  // Customer methods
  async getCustomer(id: number): Promise<Customer | undefined> {
    try {
      const result = await db.select().from(customers).where(eq(customers.id, id)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching customer:', error);
      return undefined;
    }
  }

  async getAllCustomers(): Promise<Customer[]> {
    try {
      return await db.select().from(customers).orderBy(customers.name);
    } catch (error) {
      console.error('Error fetching all customers:', error);
      return [];
    }
  }

  async createCustomer(customer: InsertCustomer): Promise<Customer> {
    try {
      const [newCustomer] = await db.insert(customers).values(customer).returning();
      return newCustomer;
    } catch (error) {
      console.error('Error creating customer:', error);
      throw error;
    }
  }

  async updateCustomer(id: number, customerData: Partial<InsertCustomer>): Promise<Customer | undefined> {
    try {
      const [updatedCustomer] = await db.update(customers)
        .set({ ...customerData, updatedAt: new Date() })
        .where(eq(customers.id, id))
        .returning();
      
      return updatedCustomer;
    } catch (error) {
      console.error('Error updating customer:', error);
      return undefined;
    }
  }

  async deleteCustomer(id: number): Promise<boolean> {
    try {
      await db.delete(customers).where(eq(customers.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting customer:', error);
      return false;
    }
  }

  // Project methods
  async getProject(id: number): Promise<Project | undefined> {
    try {
      const result = await db.select({
        ...projects,
        customerDetails: customers
      })
      .from(projects)
      .leftJoin(customers, eq(projects.customerId, customers.id))
      .where(eq(projects.id, id))
      .limit(1);
      
      return result[0];
    } catch (error) {
      console.error('Error fetching project:', error);
      return undefined;
    }
  }

  async getProjects(userId: number): Promise<Project[]> {
    try {
      return await db.select({
        ...projects,
        customerDetails: customers
      })
      .from(projects)
      .leftJoin(customers, eq(projects.customerId, customers.id))
      .where(eq(projects.userId, userId))
      .orderBy(desc(projects.updatedAt));
    } catch (error) {
      console.error('Error fetching projects:', error);
      return [];
    }
  }

  async createProject(project: InsertProject): Promise<Project> {
    try {
      const [newProject] = await db.insert(projects).values(project).returning();
      
      // Fetch customer details if customerId is provided
      if (newProject.customerId) {
        const customerResult = await db.select().from(customers).where(eq(customers.id, newProject.customerId)).limit(1);
        if (customerResult.length > 0) {
          return {
            ...newProject,
            customerDetails: customerResult[0]
          };
        }
      }
      
      return newProject;
    } catch (error) {
      console.error('Error creating project:', error);
      throw error;
    }
  }

  async updateProject(id: number, projectData: Partial<InsertProject>): Promise<Project | undefined> {
    try {
      const [updatedProject] = await db.update(projects)
        .set({ ...projectData, updatedAt: new Date() })
        .where(eq(projects.id, id))
        .returning();
      
      // Fetch customer details if customerId is provided
      if (updatedProject.customerId) {
        const customerResult = await db.select().from(customers).where(eq(customers.id, updatedProject.customerId)).limit(1);
        if (customerResult.length > 0) {
          return {
            ...updatedProject,
            customerDetails: customerResult[0]
          };
        }
      }
      
      return updatedProject;
    } catch (error) {
      console.error('Error updating project:', error);
      return undefined;
    }
  }

  async deleteProject(id: number): Promise<boolean> {
    try {
      await db.delete(projects).where(eq(projects.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting project:', error);
      return false;
    }
  }

  // Input data methods
  async getInputData(id: number): Promise<InputData | undefined> {
    try {
      const result = await db.select().from(inputData).where(eq(inputData.id, id)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching input data:', error);
      return undefined;
    }
  }

  async getInputDataByProject(projectId: number): Promise<InputData[]> {
    try {
      return await db.select().from(inputData)
        .where(eq(inputData.projectId, projectId))
        .orderBy(desc(inputData.createdAt));
    } catch (error) {
      console.error('Error fetching input data by project:', error);
      return [];
    }
  }

  async createInputData(data: InsertInputData): Promise<InputData> {
    try {
      const [newInputData] = await db.insert(inputData).values(data).returning();
      return newInputData;
    } catch (error) {
      console.error('Error creating input data:', error);
      throw error;
    }
  }

  async updateInputData(id: number, data: Partial<InsertInputData>): Promise<InputData | undefined> {
    try {
      // If status is "completed", also set processed to true
      if (data.status === "completed") {
        data.processed = true;
      }
      
      const [updatedInputData] = await db.update(inputData)
        .set(data)
        .where(eq(inputData.id, id))
        .returning();
      
      return updatedInputData;
    } catch (error) {
      console.error('Error updating input data:', error);
      return undefined;
    }
  }

  async deleteInputData(id: number): Promise<boolean> {
    try {
      await db.delete(inputData).where(eq(inputData.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting input data:', error);
      return false;
    }
  }

  // Requirement methods
  async getRequirement(id: number): Promise<Requirement | undefined> {
    try {
      const result = await db.select().from(requirements).where(eq(requirements.id, id)).limit(1);
      return result[0];
    } catch (error) {
      console.error('Error fetching requirement:', error);
      return undefined;
    }
  }
  
  async getRequirementWithProjectCheck(id: number, projectId: number): Promise<Requirement | undefined> {
    try {
      const result = await db.select().from(requirements)
        .where(and(
          eq(requirements.id, id),
          eq(requirements.projectId, projectId)
        ))
        .limit(1);
      
      return result[0];
    } catch (error) {
      console.error('Error fetching requirement with project check:', error);
      return undefined;
    }
  }

  async getRequirementsByProject(projectId: number): Promise<Requirement[]> {
    try {
      return await db.select().from(requirements)
        .where(eq(requirements.projectId, projectId))
        .orderBy(desc(requirements.updatedAt));
    } catch (error) {
      console.error('Error fetching requirements by project:', error);
      return [];
    }
  }

  async getRequirementsByInputData(inputDataId: number): Promise<Requirement[]> {
    try {
      return await db.select().from(requirements)
        .where(eq(requirements.inputDataId, inputDataId))
        .orderBy(desc(requirements.updatedAt));
    } catch (error) {
      console.error('Error fetching requirements by input data:', error);
      return [];
    }
  }

  async createRequirement(requirement: InsertRequirement): Promise<Requirement> {
    try {
      const [newRequirement] = await db.insert(requirements).values(requirement).returning();
      return newRequirement;
    } catch (error) {
      console.error('Error creating requirement:', error);
      throw error;
    }
  }

  async updateRequirement(id: number, reqData: Partial<InsertRequirement>): Promise<Requirement | undefined> {
    try {
      const [updatedRequirement] = await db.update(requirements)
        .set({ ...reqData, updatedAt: new Date() })
        .where(eq(requirements.id, id))
        .returning();
      
      return updatedRequirement;
    } catch (error) {
      console.error('Error updating requirement:', error);
      return undefined;
    }
  }

  async deleteRequirement(id: number): Promise<boolean> {
    try {
      await db.delete(requirements).where(eq(requirements.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting requirement:', error);
      return false;
    }
  }

  async getHighPriorityRequirements(projectId: number, limit: number = 10): Promise<Requirement[]> {
    try {
      return await db.select().from(requirements)
        .where(and(
          eq(requirements.projectId, projectId),
          eq(requirements.priority, "high")
        ))
        .orderBy(desc(requirements.updatedAt))
        .limit(limit);
    } catch (error) {
      console.error('Error fetching high priority requirements:', error);
      return [];
    }
  }
  
  // Method to invalidate cached requirement data
  invalidateRequirementCache(id: number): void {
    // For DatabaseStorage, this ensures we don't have stale data
    console.log(`Invalidating cache for requirement ID: ${id}`);
  }

  // Activity methods
  async getActivitiesByProject(projectId: number, limit: number = 10): Promise<Activity[]> {
    try {
      return await db.select().from(activities)
        .where(eq(activities.projectId, projectId))
        .orderBy(desc(activities.createdAt))
        .limit(limit);
    } catch (error) {
      console.error('Error fetching activities by project:', error);
      return [];
    }
  }
  
  async getAllActivities(limit: number = 10): Promise<Activity[]> {
    try {
      return await db.select().from(activities)
        .orderBy(desc(activities.createdAt))
        .limit(limit);
    } catch (error) {
      console.error('Error fetching all activities:', error);
      return [];
    }
  }

  async createActivity(activity: InsertActivity): Promise<Activity> {
    try {
      const [newActivity] = await db.insert(activities).values(activity).returning();
      return newActivity;
    } catch (error) {
      console.error('Error creating activity:', error);
      throw error;
    }
  }

  // Implementation Task methods
  async getImplementationTask(id: number): Promise<ExtendedImplementationTask | undefined> {
    try {
      // First get the task
      const taskResult = await db.select().from(implementationTasks).where(eq(implementationTasks.id, id)).limit(1);
      if (taskResult.length === 0) return undefined;
      
      const task = taskResult[0];
      
      // Next get the requirement to determine projectId
      const reqResult = await db.select().from(requirements).where(eq(requirements.id, task.requirementId)).limit(1);
      if (reqResult.length === 0) {
        // Return task without project ID if requirement not found
        return task as ExtendedImplementationTask;
      }
      
      // Return task with project ID
      return {
        ...task,
        projectId: reqResult[0].projectId
      };
    } catch (error) {
      console.error('Error fetching implementation task:', error);
      return undefined;
    }
  }

  async getImplementationTasksByRequirement(requirementId: number): Promise<ExtendedImplementationTask[]> {
    try {
      // First get the tasks
      const tasks = await db.select().from(implementationTasks)
        .where(eq(implementationTasks.requirementId, requirementId))
        .orderBy(desc(implementationTasks.updatedAt));
      
      // Next get the requirement to determine projectId
      const reqResult = await db.select().from(requirements).where(eq(requirements.id, requirementId)).limit(1);
      if (reqResult.length === 0) {
        // Return tasks without project ID if requirement not found
        return tasks as ExtendedImplementationTask[];
      }
      
      // Return tasks with project ID
      return tasks.map(task => ({
        ...task,
        projectId: reqResult[0].projectId
      }));
    } catch (error) {
      console.error('Error fetching implementation tasks by requirement:', error);
      return [];
    }
  }

  async createImplementationTask(task: InsertImplementationTask): Promise<ImplementationTask> {
    try {
      const [newTask] = await db.insert(implementationTasks).values(task).returning();
      return newTask;
    } catch (error) {
      console.error('Error creating implementation task:', error);
      throw error;
    }
  }

  async updateImplementationTask(id: number, taskData: Partial<InsertImplementationTask>): Promise<ImplementationTask | undefined> {
    try {
      const [updatedTask] = await db.update(implementationTasks)
        .set({ ...taskData, updatedAt: new Date() })
        .where(eq(implementationTasks.id, id))
        .returning();
      
      return updatedTask;
    } catch (error) {
      console.error('Error updating implementation task:', error);
      return undefined;
    }
  }

  async deleteImplementationTask(id: number): Promise<boolean> {
    try {
      await db.delete(implementationTasks).where(eq(implementationTasks.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting implementation task:', error);
      return false;
    }
  }

  // Search methods
  async quickSearch(userId: number, query: string, limit: number = 5): Promise<{
    projects: Project[];
    requirements: Requirement[];
  }> {
    try {
      // Skip search if query is empty
      if (!query || query.trim().length === 0) {
        return { projects: [], requirements: [] };
      }

      const searchTerm = `%${query.toLowerCase()}%`;
      
      // Search projects
      const projects = await db.select({
        ...projects,
        customerDetails: customers
      })
      .from(projects)
      .leftJoin(customers, eq(projects.customerId, customers.id))
      .where(and(
        eq(projects.userId, userId),
        or(
          like(drizzleSql`lower(${projects.name})`, searchTerm),
          like(drizzleSql`lower(${projects.description})`, searchTerm)
        )
      ))
      .limit(limit);
      
      // Search requirements
      const requirementResults = await db.select({
        requirement: requirements,
        project: projects
      })
        .from(requirements)
        .innerJoin(projects, eq(requirements.projectId, projects.id))
        .where(and(
          eq(projects.userId, userId),
          or(
            like(drizzleSql`lower(${requirements.title})`, searchTerm),
            like(drizzleSql`lower(${requirements.description})`, searchTerm),
            like(drizzleSql`lower(${requirements.category})`, searchTerm)
          )
        ))
        .limit(limit);
      
      // Extract requirements from join result
      const requirementList = requirementResults.map(r => r.requirement);
      
      return {
        projects,
        requirements: requirementList
      };
    } catch (error) {
      console.error('Error performing quick search:', error);
      return { projects: [], requirements: [] };
    }
  }

  async advancedSearch(
    userId: number, 
    query: string, 
    filters?: {
      entityTypes?: string[];
      projectId?: number;
      category?: string;
      priority?: string;
      dateRange?: { from?: Date; to?: Date };
    },
    pagination?: {
      page: number;
      limit: number;
    }
  ): Promise<{
    projects: Project[];
    requirements: Requirement[];
    inputData: InputData[];
    tasks: ExtendedImplementationTask[];
    totalResults: number;
    totalPages: number;
  }> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;
      const offset = (page - 1) * limit;
      
      // Determine which entity types to search
      const entityTypes = filters?.entityTypes || ["projects", "requirements", "inputData", "tasks"];
      const searchTerm = query ? `%${query.toLowerCase()}%` : null;
      
      let matchedProjects: Project[] = [];
      let matchedRequirements: Requirement[] = [];
      let matchedInputData: InputData[] = [];
      let matchedTasks: ExtendedImplementationTask[] = [];
      
      let projectsCount = 0;
      let requirementsCount = 0;
      let inputDataCount = 0;
      let tasksCount = 0;
      
      // Search projects
      if (entityTypes.includes("projects")) {
        // Build conditions
        const conditions = [eq(projects.userId, userId)];
        
        if (searchTerm) {
          conditions.push(or(
            like(drizzleSql`lower(${projects.name})`, searchTerm),
            like(drizzleSql`lower(${projects.description})`, searchTerm)
          ));
        }
        
        if (filters?.dateRange?.from) {
          conditions.push(gte(projects.createdAt, filters.dateRange.from));
        }
        
        if (filters?.dateRange?.to) {
          const endDate = new Date(filters.dateRange.to);
          endDate.setHours(23, 59, 59, 999);
          conditions.push(lte(projects.createdAt, endDate));
        }
        
        // Count total matching projects
        const projectCountResult = await db.select({ count: sql`count(*)` })
          .from(projects)
          .where(and(...conditions));
        
        projectsCount = Number(projectCountResult[0].count);
        
        // Get paginated projects
        matchedProjects = await db.select({
          ...projects,
          customerDetails: customers
        })
        .from(projects)
        .leftJoin(customers, eq(projects.customerId, customers.id))
        .where(and(...conditions))
        .orderBy(desc(projects.updatedAt))
        .limit(limit)
        .offset(offset);
      }
      
      // Search requirements
      if (entityTypes.includes("requirements")) {
        // Build conditions
        let conditions = [];
        
        if (filters?.projectId) {
          conditions.push(eq(requirements.projectId, filters.projectId));
        } else {
          // Only search requirements for projects owned by this user
          const subquery = db.select({ id: projects.id })
            .from(projects)
            .where(eq(projects.userId, userId));
          
          conditions.push(sql`${requirements.projectId} IN (${subquery})`);
        }
        
        if (searchTerm) {
          conditions.push(or(
            like(drizzleSql`lower(${requirements.title})`, searchTerm),
            like(drizzleSql`lower(${requirements.description})`, searchTerm),
            like(drizzleSql`lower(${requirements.category})`, searchTerm)
          ));
        }
        
        if (filters?.category) {
          conditions.push(eq(requirements.category, filters.category));
        }
        
        if (filters?.priority) {
          conditions.push(eq(requirements.priority, filters.priority));
        }
        
        if (filters?.dateRange?.from) {
          conditions.push(gte(requirements.createdAt, filters.dateRange.from));
        }
        
        if (filters?.dateRange?.to) {
          const endDate = new Date(filters.dateRange.to);
          endDate.setHours(23, 59, 59, 999);
          conditions.push(lte(requirements.createdAt, endDate));
        }
        
        // Count total matching requirements
        const reqCountResult = await db.select({ count: sql`count(*)` })
          .from(requirements)
          .where(and(...conditions));
        
        requirementsCount = Number(reqCountResult[0].count);
        
        // Get paginated requirements
        matchedRequirements = await db.select()
          .from(requirements)
          .where(and(...conditions))
          .orderBy(desc(requirements.updatedAt))
          .limit(limit)
          .offset(offset);
      }
      
      // Search input data
      if (entityTypes.includes("inputData")) {
        // Build conditions
        let conditions = [];
        
        if (filters?.projectId) {
          conditions.push(eq(inputData.projectId, filters.projectId));
        } else {
          // Only search input data for projects owned by this user
          const subquery = db.select({ id: projects.id })
            .from(projects)
            .where(eq(projects.userId, userId));
          
          conditions.push(sql`${inputData.projectId} IN (${subquery})`);
        }
        
        if (searchTerm) {
          conditions.push(or(
            like(drizzleSql`lower(${inputData.name})`, searchTerm),
            like(drizzleSql`lower(${inputData.contentType})`, searchTerm)
          ));
        }
        
        if (filters?.dateRange?.from) {
          conditions.push(gte(inputData.createdAt, filters.dateRange.from));
        }
        
        if (filters?.dateRange?.to) {
          const endDate = new Date(filters.dateRange.to);
          endDate.setHours(23, 59, 59, 999);
          conditions.push(lte(inputData.createdAt, endDate));
        }
        
        // Count total matching input data items
        const inputDataCountResult = await db.select({ count: sql`count(*)` })
          .from(inputData)
          .where(and(...conditions));
        
        inputDataCount = Number(inputDataCountResult[0].count);
        
        // Get paginated input data
        matchedInputData = await db.select()
          .from(inputData)
          .where(and(...conditions))
          .orderBy(desc(inputData.createdAt))
          .limit(limit)
          .offset(offset);
      }
      
      // Search tasks
      if (entityTypes.includes("tasks")) {
        // First, build a query to get tasks with their associated requirements and project IDs
        let taskQuery = db.select({
          task: implementationTasks,
          projectId: requirements.projectId
        })
        .from(implementationTasks)
        .innerJoin(requirements, eq(implementationTasks.requirementId, requirements.id));
        
        // Apply filters
        let conditions = [];
        
        if (filters?.projectId) {
          conditions.push(eq(requirements.projectId, filters.projectId));
        } else {
          // Only search tasks for projects owned by this user
          const subquery = db.select({ id: projects.id })
            .from(projects)
            .where(eq(projects.userId, userId));
          
          conditions.push(sql`${requirements.projectId} IN (${subquery})`);
        }
        
        if (searchTerm) {
          conditions.push(or(
            like(drizzleSql`lower(${implementationTasks.title})`, searchTerm),
            like(drizzleSql`lower(${implementationTasks.description})`, searchTerm)
          ));
        }
        
        if (filters?.priority) {
          conditions.push(eq(implementationTasks.priority, filters.priority));
        }
        
        if (filters?.dateRange?.from) {
          conditions.push(gte(implementationTasks.createdAt, filters.dateRange.from));
        }
        
        if (filters?.dateRange?.to) {
          const endDate = new Date(filters.dateRange.to);
          endDate.setHours(23, 59, 59, 999);
          conditions.push(lte(implementationTasks.createdAt, endDate));
        }
        
        if (conditions.length > 0) {
          taskQuery = taskQuery.where(and(...conditions));
        }
        
        // Count total matching tasks
        const taskCountResult = await db.select({ count: sql`count(*)` })
          .from(implementationTasks)
          .innerJoin(requirements, eq(implementationTasks.requirementId, requirements.id))
          .where(and(...conditions));
        
        tasksCount = Number(taskCountResult[0].count);
        
        // Get paginated tasks
        const taskResults = await taskQuery
          .orderBy(desc(implementationTasks.updatedAt))
          .limit(limit)
          .offset(offset);
        
        // Convert to ExtendedImplementationTask format
        matchedTasks = taskResults.map(result => ({
          ...result.task,
          projectId: result.projectId
        }));
      }
      
      // Calculate total results and pages
      const totalResults = projectsCount + requirementsCount + inputDataCount + tasksCount;
      const totalPages = Math.max(1, Math.ceil(totalResults / limit));
      
      return {
        projects: matchedProjects,
        requirements: matchedRequirements,
        inputData: matchedInputData,
        tasks: matchedTasks,
        totalResults,
        totalPages
      };
    } catch (error) {
      console.error('Error performing advanced search:', error);
      return {
        projects: [],
        requirements: [],
        inputData: [],
        tasks: [],
        totalResults: 0,
        totalPages: 1
      };
    }
  }
}

// Always use database storage for persistence
export const storage = new DatabaseStorage();

// Log which storage system we're using
console.log(`Storage system: PostgreSQL Database`);