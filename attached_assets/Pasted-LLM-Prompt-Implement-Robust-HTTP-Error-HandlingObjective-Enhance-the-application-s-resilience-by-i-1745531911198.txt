LLM Prompt: Implement Robust HTTP Error HandlingObjective: Enhance the application's resilience by implementing comprehensive error handling for HTTP request failures, specifically focusing on server-side errors like 502 Bad Gateway, 503 Service Unavailable, and 504 Gateway Timeout. The goal is to prevent application crashes, inform the user appropriately, and attempt recovery where feasible.Context:[Optional: Briefly describe the application, the technology stack (e.g., React frontend, Node.js backend, specific libraries used for fetching data like Axios, Fetch API), and where the HTTP requests are being made.]Requirements:Error Detection & Catching:Identify all areas in the code where external HTTP requests are made.Implement mechanisms (e.g., try...catch blocks, promise .catch() handlers, interceptors if using libraries like Axios) to reliably catch errors resulting from these requests.Specifically handle HTTP status codes in the 5xx range (500, 502, 503, 504, etc.), but also consider handling 4xx client errors where appropriate (e.g., 404 Not Found, 401 Unauthorized).Graceful Error Display:Instead of letting the application crash or show a blank/broken state, display user-friendly error messages.The message should ideally:Acknowledge that something went wrong (e.g., "Unable to load data," "Could not connect to the service").Provide context if possible (e.g., "Failed to fetch user profile," "Problem saving your settings").Avoid exposing technical details or stack traces to the end-user.Suggest a course of action (e.g., "Please try again later," "Check your internet connection," "Contact support if the problem persists").Consider using dedicated UI components (like modals, toasts/snackbars, or inline messages within the relevant section of the UI) to display these errors without disrupting the entire page layout.Recovery Logic & Retries:For transient errors (like 502, 503, 504, or network issues), implement a retry mechanism.Use a strategy like exponential backoff (wait longer between successive retries) to avoid overwhelming the server.Limit the number of retries (e.g., 3 attempts).Only attempt retries for idempotent requests (like GET) where appropriate. Avoid retrying non-idempotent requests (like POST) automatically unless you are certain it's safe to do so.If retries fail, then display the user-friendly error message as described above.Logging:Implement server-side or client-side logging to record these errors (including status code, requested URL, timestamp, and potentially a correlation ID) for debugging and monitoring purposes. Do not log sensitive user data.Example Scenario (502 Bad Gateway):User tries to load their dashboard.The frontend makes an API call to /api/dashboard-data.The backend service responsible is temporarily down, and the gateway returns a 502 error.Instead of crashing: The frontend code catches the 502 error.Retry: It automatically retries the request after 1 second, then 3 seconds.Failure & Display: If both retries fail, the application displays a message like: "We couldn't load your dashboard data right now. Please try again in a few minutes." within the dashboard area, rather than showing a broken page.Logging: The error (502 on /api/dashboard-data) is logged.Deliverable:Provide the modified code implementing the error handling logic as described above. Include comments explaining the changes, particularly the error catching, message display, and retry mechanisms.